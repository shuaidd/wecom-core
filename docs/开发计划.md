# wecom-core SDK 开发计划

## 一、项目分析总结

### 1.1 接口调用规范

通过对企业微信接口文档的分析，了解到以下规范：

- **协议与格式**：所有接口使用 HTTPS + JSON + UTF8
- **鉴权机制**：需要 access_token 鉴权（有效期 7200 秒）
- **错误处理**：统一错误码机制（errcode != 0 为失败）
- **频率限制**：存在调用频率限制，需要合理控制请求频率
- **可信 IP**：需要在管理端配置可信 IP

### 1.2 核心挑战

- **Token 管理**：access_token 需要缓存和自动刷新
- **失效重试**：token 失效需要自动重新获取并重试
- **统一重试**：网络错误、频率限制等场景需要智能重试
- **日志监控**：需要完善的日志记录和监控能力
- **大规模扩展**：企业微信有 30+ 个业务模块，需要良好的代码组织

### 1.3 业务模块

基于已有文档和企业微信 API 规模：

- 通讯录管理（成员、部门、标签等 20+ 接口）
- 消息推送（应用消息、群聊消息等）
- 身份验证（OAuth2）
- 客户联系（外部联系人管理）
- 会议、日程、打卡、审批等 30+ 个业务模块

---

## 二、优化后的目录结构（支持大规模扩展）

```
wecom-core/
├── wecom.go                    # 主入口，对外暴露的根 Client
├── config/                     # 配置管理
│   ├── config.go              # 配置定义
│   └── options.go             # 选项模式
│
├── internal/                   # 内部包（不对外暴露）
│   ├── client/                # HTTP 客户端
│   │   ├── client.go          # 基础 HTTP 客户端
│   │   ├── request.go         # 请求构建
│   │   └── response.go        # 响应解析
│   ├── auth/                  # 认证管理
│   │   ├── token.go           # Token 管理器
│   │   ├── cache.go           # 缓存接口
│   │   └── memory_cache.go    # 内存缓存实现
│   ├── retry/                 # 重试逻辑
│   │   ├── retry.go           # 重试策略
│   │   └── backoff.go         # 退避算法
│   └── errors/                # 错误处理
│       ├── errors.go          # 错误定义
│       └── codes.go           # 错误码映射
│
├── pkg/                        # 公共包（可被外部引用）
│   ├── logger/                # 日志接口
│   │   ├── logger.go          # 日志接口定义
│   │   ├── noop.go            # 空实现
│   │   └── std.go             # 标准输出实现
│   └── cache/                 # 缓存接口（供用户自定义）
│       └── cache.go           # Cache 接口定义
│
├── types/                      # 数据类型定义（按业务域分组）
│   ├── common/                # 通用类型
│   │   ├── response.go        # 通用响应
│   │   └── error.go           # 错误响应
│   ├── contact/               # 通讯录相关
│   │   ├── user.go            # 成员类型
│   │   ├── department.go      # 部门类型
│   │   └── tag.go             # 标签类型
│   ├── message/               # 消息相关
│   │   ├── text.go
│   │   ├── image.go
│   │   └── card.go
│   ├── externalcontact/       # 客户联系相关
│   │   ├── customer.go
│   │   └── contact_way.go
│   └── ...                    # 其他业务域
│
├── services/                   # 业务服务（按功能域分组）
│   │
│   ├── contact/               # 通讯录管理（多个子模块）
│   │   ├── contact.go         # 服务入口
│   │   ├── user.go            # 成员管理
│   │   ├── department.go      # 部门管理
│   │   ├── tag.go             # 标签管理
│   │   └── batch.go           # 批量操作
│   │
│   ├── message/               # 消息推送
│   │   ├── message.go         # 服务入口
│   │   ├── send.go            # 发送消息
│   │   ├── template.go        # 模板消息
│   │   └── appchat.go         # 群聊消息
│   │
│   ├── oauth/                 # 身份验证
│   │   ├── oauth.go           # 服务入口
│   │   ├── authorize.go       # 授权
│   │   └── userinfo.go        # 获取用户信息
│   │
│   ├── externalcontact/       # 客户联系
│   │   ├── externalcontact.go # 服务入口
│   │   ├── customer.go        # 客户管理
│   │   ├── contact_way.go     # 联系方式
│   │   ├── group_chat.go      # 客户群
│   │   └── moment.go          # 朋友圈
│   │
│   ├── meeting/               # 会议
│   ├── calendar/              # 日程
│   ├── checkin/               # 打卡
│   ├── approval/              # 审批
│   ├── oa/                    # OA 办公
│   ├── kf/                    # 客服
│   ├── wedrive/               # 微盘
│   ├── living/                # 直播
│   └── ...                    # 其他业务模块（30+ 个）
│
├── examples/                   # 使用示例
│   ├── basic/                 # 基础示例
│   │   └── main.go
│   ├── contact/               # 通讯录示例
│   │   └── main.go
│   └── message/               # 消息示例
│       └── main.go
│
├── test/                       # 测试相关
│   ├── mock/                  # Mock 数据
│   └── integration/           # 集成测试
│
├── scripts/                    # 脚本工具
│   └── generate.sh            # 代码生成脚本
│
├── docs/                       # 文档（企业微信官方文档）
├── go.mod
├── go.sum
├── README.md
├── CHANGELOG.md
└── LICENSE
```

### 2.1 关键设计决策

#### internal vs pkg 的使用

```go
// ✅ internal/ - 内部实现，不对外暴露
// 防止用户直接依赖内部实现，保持 API 稳定性
wecom-core/internal/client/     // 用户不能 import
wecom-core/internal/auth/       // 用户不能 import

// ✅ pkg/ - 可复用的公共包，允许外部引用
wecom-core/pkg/logger/          // 用户可以 import，实现自定义 Logger
wecom-core/pkg/cache/           // 用户可以 import，实现自定义 Cache
```

#### types 按业务域分组

```go
// ❌ 不推荐：所有类型堆在一起
types/
  ├── user.go          (100+ 个类型)
  ├── department.go    (混乱、难以维护)
  └── message.go

// ✅ 推荐：按业务域分组
types/
  ├── contact/         (通讯录相关的所有类型)
  │   ├── user.go
  │   ├── department.go
  │   └── tag.go
  ├── message/         (消息相关的所有类型)
  │   ├── text.go
  │   └── image.go
  └── externalcontact/ (客户联系相关)
```

#### services 按功能域组织

每个功能域一个目录，域内可有多个文件：

```go
services/contact/
├── contact.go      # 服务入口 + 初始化
├── user.go         # 成员相关的所有方法（10-15 个）
├── department.go   # 部门相关的所有方法（10-15 个）
├── tag.go          # 标签相关的所有方法（10-15 个）
└── batch.go        # 批量操作
```

---

## 三、核心功能模块

### 3.1 统一 HTTP 客户端 (`internal/client`)

**职责**：
- 封装所有 HTTP 请求
- 自动添加 access_token 参数
- 统一请求日志记录
- 超时控制
- 请求/响应拦截器支持

**关键特性**：
```go
type Client struct {
    httpClient  *http.Client
    baseURL     string
    tokenManager *auth.TokenManager
    logger      logger.Logger
    retryPolicy *retry.Policy
}

func (c *Client) Do(ctx context.Context, req *Request) (*Response, error) {
    // 1. 获取 token
    // 2. 构建请求
    // 3. 记录日志
    // 4. 发送请求
    // 5. 处理响应
    // 6. 错误重试
}
```

### 3.2 Token 管理器 (`internal/auth`)

**职责**：
- 自动获取 access_token
- 内存/Redis 缓存支持（可扩展）
- 过期前自动刷新（提前 5 分钟）
- 并发安全（防止重复获取）
- token 失效检测与重新获取

**关键特性**：
```go
type TokenManager struct {
    corpID       string
    corpSecret   string
    cache        Cache
    refreshLock  sync.Mutex
    expiresIn    time.Duration
}

func (tm *TokenManager) GetToken(ctx context.Context) (string, error) {
    // 1. 从缓存获取
    // 2. 检查是否过期
    // 3. 未过期直接返回
    // 4. 过期则加锁刷新
    // 5. 刷新成功更新缓存
}

func (tm *TokenManager) RefreshToken(ctx context.Context) error {
    // 强制刷新 token（用于失效重试）
}
```

### 3.3 统一响应处理 (`internal/client`)

**职责**：
- 解析标准 JSON 响应
- 根据 errcode 判断成功/失败
- 自动解析错误信息
- 类型安全的数据返回

**关键特性**：
```go
type CommonResponse struct {
    ErrCode int    `json:"errcode"`
    ErrMsg  string `json:"errmsg"`
}

func ParseResponse(resp *http.Response, result interface{}) error {
    // 1. 读取响应体
    // 2. 解析 errcode
    // 3. 错误处理
    // 4. 反序列化到 result
}
```

### 3.4 智能重试机制 (`internal/retry`)

**职责**：
- Token 失效自动重试
- 网络超时重试
- 频率限制重试（指数退避）
- 可配置重试次数和间隔
- 重试日志记录

**关键特性**：
```go
type Policy struct {
    MaxRetries int
    InitialBackoff time.Duration
    MaxBackoff time.Duration
}

func (p *Policy) ShouldRetry(err error) bool {
    // 判断错误是否需要重试
    // - Token 失效：errcode 40014, 42001
    // - 频率限制：errcode 45009
    // - 网络超时
}

func (p *Policy) Backoff(attempt int) time.Duration {
    // 指数退避算法
}
```

### 3.5 统一错误处理 (`internal/errors`)

**职责**：
- 定义标准错误类型
- 企业微信错误码映射
- 错误链支持（wrap）
- 便于上层业务处理

**关键特性**：
```go
type Error struct {
    Code    int
    Message string
    Cause   error
}

// 常见错误码定义
const (
    ErrCodeTokenExpired  = 40014  // Token 过期
    ErrCodeTokenInvalid  = 42001  // Token 无效
    ErrCodeRateLimit     = 45009  // 频率限制
)

func IsTokenExpired(err error) bool
func IsRateLimited(err error) bool
```

### 3.6 日志监控 (`pkg/logger`)

**职责**：
- 接口化设计，支持自定义实现
- 默认提供标准输出实现
- 记录关键信息
- 支持日志级别

**记录内容**：
- 请求：URL、参数、耗时
- 响应：状态码、返回值
- Token：获取、刷新、失效
- 重试：触发原因、次数

**接口定义**：
```go
type Logger interface {
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
}

type Field struct {
    Key   string
    Value interface{}
}
```

---

## 四、对外 API 设计

### 4.1 主入口 (`wecom.go`)

```go
package wecom

import (
    "github.com/shuaidd/wecom-core/config"
    "github.com/shuaidd/wecom-core/services/contact"
    "github.com/shuaidd/wecom-core/services/message"
    // ... 其他服务
)

// Client 是 wecom SDK 的主客户端
type Client struct {
    // 业务服务（按功能域分组）
    Contact         *contact.Service
    Message         *message.Service
    OAuth           *oauth.Service
    ExternalContact *externalcontact.Service
    Meeting         *meeting.Service
    Calendar        *calendar.Service
    Checkin         *checkin.Service
    Approval        *approval.Service
    OA              *oa.Service
    KF              *kf.Service
    WeDrive         *wedrive.Service
    Living          *living.Service
    // ... 30+ 个服务字段
}

// New 创建 wecom 客户端
func New(opts ...config.Option) (*Client, error) {
    cfg := config.New(opts...)

    // 创建内部客户端
    internalClient := internal.NewClient(cfg)

    return &Client{
        Contact:         contact.NewService(internalClient),
        Message:         message.NewService(internalClient),
        ExternalContact: externalcontact.NewService(internalClient),
        // ... 初始化所有服务
    }, nil
}
```

### 4.2 配置选项 (`config/options.go`)

```go
package config

type Option func(*Config)

func WithCorpID(corpID string) Option {
    return func(c *Config) {
        c.CorpID = corpID
    }
}

func WithCorpSecret(secret string) Option {
    return func(c *Config) {
        c.CorpSecret = secret
    }
}

func WithLogger(logger logger.Logger) Option {
    return func(c *Config) {
        c.Logger = logger
    }
}

func WithRetry(maxRetries int) Option {
    return func(c *Config) {
        c.MaxRetries = maxRetries
    }
}

func WithTimeout(timeout time.Duration) Option {
    return func(c *Config) {
        c.Timeout = timeout
    }
}

func WithCache(cache cache.Cache) Option {
    return func(c *Config) {
        c.Cache = cache
    }
}
```

### 4.3 使用示例

```go
package main

import (
    "context"
    "github.com/shuaidd/wecom-core"
    "github.com/shuaidd/wecom-core/config"
    "github.com/shuaidd/wecom-core/types/contact"
)

func main() {
    // 1. 创建客户端
    client, err := wecom.New(
        config.WithCorpID("your_corp_id"),
        config.WithCorpSecret("your_secret"),
        config.WithLogger(myLogger),
        config.WithRetry(3),
    )
    if err != nil {
        panic(err)
    }

    // 2. 使用通讯录服务 - 创建成员
    user, err := client.Contact.CreateUser(context.Background(), &contact.CreateUserRequest{
        UserID:     "zhangsan",
        Name:       "张三",
        Mobile:     "13800000000",
        Department: []int{1},
    })
    if err != nil {
        panic(err)
    }
    println("成员创建成功:", user.UserID)

    // 3. 使用通讯录服务 - 读取成员
    user, err = client.Contact.GetUser(context.Background(), "zhangsan")
    if err != nil {
        panic(err)
    }
    println("成员信息:", user.Name, user.Mobile)

    // 4. 使用消息服务
    err = client.Message.SendText(context.Background(), &message.SendTextRequest{
        ToUser:  "zhangsan",
        Content: "Hello, 这是一条测试消息",
    })
    if err != nil {
        panic(err)
    }

    // 5. 使用客户联系服务
    customers, err := client.ExternalContact.ListCustomers(context.Background(), "zhangsan")
    if err != nil {
        panic(err)
    }
    println("客户数量:", len(customers))
}
```

---

## 五、技术选型

### 5.1 编程语言与版本

- **Go 版本**：1.25+
- **原因**：利用最新的语言特性和性能优化

### 5.2 依赖库

- **HTTP 库**：标准库 `net/http`
  - 稳定、高性能
  - 无需引入第三方依赖

- **JSON 处理**：标准库 `encoding/json`
  - 满足需求
  - 可选：`json-iterator` 提升性能

- **日志**：接口化设计
  - 默认：`log` 标准库
  - 支持：`zap`、`logrus`、`slog` 等

- **缓存**：接口化设计
  - 默认：内存缓存（`sync.Map`）
  - 可选：Redis（通过接口扩展）

- **测试**：
  - 标准库 `testing`
  - `github.com/stretchr/testify` - 断言和 Mock

### 5.3 设计原则

- **依赖倒置**：依赖接口而非实现
- **开闭原则**：对扩展开放，对修改封闭
- **单一职责**：每个模块职责清晰
- **接口隔离**：提供最小化接口

---

## 六、实现计划（分阶段）

### 阶段一：基础框架

**目标**：搭建核心架构，实现基础能力

**任务清单**：
1. 项目结构搭建
   - 创建目录结构
   - 初始化 go.mod
   - 配置 .gitignore

2. 配置管理 (`config/`)
   - 定义 Config 结构
   - 实现 Options 模式
   - 默认值设置

3. 日志接口 (`pkg/logger/`)
   - 定义 Logger 接口
   - 实现 NoopLogger（空实现）
   - 实现 StdLogger（标准输出）

4. 错误处理 (`internal/errors/`)
   - 定义标准错误类型
   - 企业微信错误码映射
   - 错误判断辅助函数

5. HTTP 客户端 (`internal/client/`)
   - 基础 Client 实现
   - Request 构建
   - Response 解析
   - 单元测试

**交付成果**：
- 完整的项目骨架
- 基础 HTTP 请求能力
- 完善的错误处理
- 单元测试覆盖率 > 80%

---

### 阶段二：认证与重试

**目标**：实现 Token 管理和智能重试

**任务清单**：
1. 缓存接口 (`pkg/cache/`)
   - 定义 Cache 接口
   - 实现 MemoryCache

2. Token 管理器 (`internal/auth/`)
   - Token 获取逻辑
   - 缓存机制
   - 自动刷新（提前 5 分钟）
   - 并发安全控制
   - Token 失效处理

3. 重试策略 (`internal/retry/`)
   - 定义 Policy 结构
   - 实现指数退避算法
   - 错误判断逻辑（Token 失效、频率限制）
   - 重试日志记录

4. 集成到 Client
   - Client 集成 TokenManager
   - Client 集成 RetryPolicy
   - 自动重试流程
   - 集成测试

**交付成果**：
- 完整的 Token 自动管理
- 智能重试机制
- Token 失效自动恢复
- 集成测试验证

---

### 阶段三：第一个业务模块（通讯录）

**目标**：实现通讯录模块，验证架构设计

**任务清单**：
1. 数据类型定义 (`types/contact/`)
   - User 相关类型
   - Department 相关类型
   - Tag 相关类型
   - Request/Response 结构

2. 成员管理 (`services/contact/user.go`)
   - CreateUser - 创建成员
   - GetUser - 读取成员
   - UpdateUser - 更新成员
   - DeleteUser - 删除成员
   - ListUsers - 批量读取成员

3. 部门管理 (`services/contact/department.go`)
   - CreateDepartment - 创建部门
   - GetDepartment - 读取部门
   - UpdateDepartment - 更新部门
   - DeleteDepartment - 删除部门
   - ListDepartments - 获取部门列表

4. 标签管理 (`services/contact/tag.go`)
   - CreateTag - 创建标签
   - UpdateTag - 更新标签
   - DeleteTag - 删除标签
   - GetTag - 获取标签
   - AddTagUsers - 添加成员到标签
   - RemoveTagUsers - 从标签移除成员

5. 主客户端 (`wecom.go`)
   - Client 结构定义
   - New 函数实现
   - 初始化各服务

6. 测试与示例
   - 单元测试
   - 集成测试
   - 使用示例（examples/contact/）

**交付成果**：
- 完整的通讯录模块
- 可用的 SDK（支持通讯录功能）
- 完善的测试和示例
- README 文档

---

### 阶段四：扩展更多业务模块

**目标**：逐步添加其他业务模块

**任务清单**：

**优先级 P0（核心功能）**：
1. 消息推送 (`services/message/`)
   - 发送应用消息
   - 发送文本、图片、视频等
   - 群聊消息

2. 身份验证 (`services/oauth/`)
   - OAuth2 授权
   - 获取用户信息

**优先级 P1（常用功能）**：
3. 客户联系 (`services/externalcontact/`)
   - 客户管理
   - 联系方式
   - 客户群管理

4. 应用管理 (`services/agent/`)
   - 获取应用信息
   - 设置应用

**优先级 P2（按需实现）**：
5. 会议 (`services/meeting/`)
6. 日程 (`services/calendar/`)
7. 打卡 (`services/checkin/`)
8. 审批 (`services/approval/`)
9. OA 办公 (`services/oa/`)
10. ... 其他 20+ 个模块

**实现策略**：
- 每个模块独立开发、测试
- 遵循统一的代码规范
- 复用核心能力（Client、Token、Retry）
- 逐步完善文档和示例

---

### 阶段五：测试与优化

**目标**：提高代码质量和性能

**任务清单**：
1. 测试完善
   - 单元测试覆盖率 > 80%
   - 集成测试覆盖核心流程
   - 压力测试（并发场景）
   - Mock 企业微信 API

2. 代码质量
   - golangci-lint 静态检查
   - 代码审查
   - 注释完善（GoDoc）

3. 性能优化
   - HTTP 连接池优化
   - Token 缓存优化
   - 减少内存分配
   - 并发控制

4. 文档完善
   - README 使用指南
   - API 文档（GoDoc）
   - 最佳实践文档
   - 常见问题 FAQ

**交付成果**：
- 高质量、高性能的 SDK
- 完善的文档
- 良好的开发者体验

---

### 阶段六：工具与扩展（可选）

**目标**：提供辅助工具和高级功能

**任务清单**：
1. 代码生成工具
   - 根据 API 文档自动生成代码
   - 减少重复劳动

2. Redis 缓存支持
   - 实现 RedisCache
   - 支持分布式部署

3. 监控与追踪
   - Prometheus Metrics
   - OpenTelemetry 追踪
   - 请求统计

4. CLI 工具
   - 命令行工具
   - 快速调试和测试

**交付成果**：
- 提升开发效率的工具
- 生产级特性支持

---

## 七、关键技术实现

### 7.1 Token 自动刷新

```go
package auth

import (
    "context"
    "sync"
    "time"
)

type TokenManager struct {
    corpID       string
    corpSecret   string
    cache        Cache
    client       HTTPClient
    refreshLock  sync.Mutex
    logger       logger.Logger
}

func (tm *TokenManager) GetToken(ctx context.Context) (string, error) {
    // 1. 从缓存获取
    token, expireAt, err := tm.cache.Get(ctx, tm.cacheKey())
    if err == nil && time.Now().Before(expireAt) {
        return token, nil
    }

    // 2. 加锁刷新（防止并发重复获取）
    tm.refreshLock.Lock()
    defer tm.refreshLock.Unlock()

    // 3. Double-check（可能已被其他协程刷新）
    token, expireAt, err = tm.cache.Get(ctx, tm.cacheKey())
    if err == nil && time.Now().Before(expireAt) {
        return token, nil
    }

    // 4. 调用 API 获取 token
    token, expiresIn, err := tm.fetchTokenFromAPI(ctx)
    if err != nil {
        tm.logger.Error("Failed to fetch token",
            logger.Field("error", err))
        return "", err
    }

    // 5. 缓存 token（提前 5 分钟过期）
    expireAt = time.Now().Add(time.Duration(expiresIn-300) * time.Second)
    tm.cache.Set(ctx, tm.cacheKey(), token, expireAt)

    tm.logger.Info("Token refreshed successfully",
        logger.Field("expires_in", expiresIn))

    return token, nil
}

func (tm *TokenManager) RefreshToken(ctx context.Context) error {
    // 强制刷新（用于 token 失效重试）
    tm.refreshLock.Lock()
    defer tm.refreshLock.Unlock()

    token, expiresIn, err := tm.fetchTokenFromAPI(ctx)
    if err != nil {
        return err
    }

    expireAt := time.Now().Add(time.Duration(expiresIn-300) * time.Second)
    tm.cache.Set(ctx, tm.cacheKey(), token, expireAt)

    return nil
}
```

### 7.2 智能重试机制

```go
package retry

import (
    "context"
    "time"
    "github.com/shuaidd/wecom-core/internal/errors"
)

type Policy struct {
    MaxRetries     int
    InitialBackoff time.Duration
    MaxBackoff     time.Duration
    logger         logger.Logger
}

func (p *Policy) Do(ctx context.Context, fn func() error) error {
    var lastErr error

    for attempt := 0; attempt <= p.MaxRetries; attempt++ {
        // 执行函数
        err := fn()
        if err == nil {
            return nil
        }

        lastErr = err

        // 判断是否需要重试
        if !p.ShouldRetry(err) {
            p.logger.Info("Error not retriable",
                logger.Field("error", err))
            return err
        }

        // 最后一次尝试失败
        if attempt == p.MaxRetries {
            p.logger.Warn("Max retries reached",
                logger.Field("attempts", attempt+1),
                logger.Field("error", err))
            break
        }

        // 计算退避时间
        backoff := p.Backoff(attempt)
        p.logger.Info("Retrying after backoff",
            logger.Field("attempt", attempt+1),
            logger.Field("backoff", backoff),
            logger.Field("error", err))

        // 等待
        select {
        case <-time.After(backoff):
        case <-ctx.Done():
            return ctx.Err()
        }
    }

    return lastErr
}

func (p *Policy) ShouldRetry(err error) bool {
    // Token 失效
    if errors.IsTokenExpired(err) {
        return true
    }

    // 频率限制
    if errors.IsRateLimited(err) {
        return true
    }

    // 网络超时
    if errors.IsTimeout(err) {
        return true
    }

    return false
}

func (p *Policy) Backoff(attempt int) time.Duration {
    // 指数退避：InitialBackoff * 2^attempt
    backoff := p.InitialBackoff * (1 << attempt)
    if backoff > p.MaxBackoff {
        return p.MaxBackoff
    }
    return backoff
}
```

### 7.3 请求处理流程

```go
package client

func (c *Client) Do(ctx context.Context, req *Request) (*Response, error) {
    // 使用重试策略
    var resp *Response
    err := c.retryPolicy.Do(ctx, func() error {
        // 1. 获取 access_token
        token, err := c.tokenManager.GetToken(ctx)
        if err != nil {
            return err
        }

        // 2. 添加 token 到请求
        req.AddQuery("access_token", token)

        // 3. 构建 HTTP 请求
        httpReq, err := c.buildHTTPRequest(ctx, req)
        if err != nil {
            return err
        }

        // 4. 记录请求日志
        startTime := time.Now()
        c.logger.Debug("API Request",
            logger.Field("url", httpReq.URL.String()),
            logger.Field("method", httpReq.Method))

        // 5. 发送请求
        httpResp, err := c.httpClient.Do(httpReq)
        if err != nil {
            c.logger.Error("Request failed",
                logger.Field("error", err),
                logger.Field("duration", time.Since(startTime)))
            return err
        }
        defer httpResp.Body.Close()

        // 6. 解析响应
        resp, err = c.parseResponse(httpResp)
        if err != nil {
            c.logger.Error("Failed to parse response",
                logger.Field("error", err),
                logger.Field("duration", time.Since(startTime)))
            return err
        }

        // 7. 检查错误码
        if resp.ErrCode != 0 {
            err := errors.New(resp.ErrCode, resp.ErrMsg)

            // Token 失效，刷新后重试
            if errors.IsTokenExpired(err) {
                c.logger.Warn("Token expired, refreshing",
                    logger.Field("errcode", resp.ErrCode))
                c.tokenManager.RefreshToken(ctx)
            }

            return err
        }

        // 8. 记录成功日志
        c.logger.Info("API Request successful",
            logger.Field("url", httpReq.URL.String()),
            logger.Field("duration", time.Since(startTime)))

        return nil
    })

    if err != nil {
        return nil, err
    }

    return resp, nil
}
```

### 7.4 统一日志记录

```go
package logger

type Logger interface {
    Debug(msg string, fields ...Field)
    Info(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    Error(msg string, fields ...Field)
}

type Field struct {
    Key   string
    Value interface{}
}

// 标准输出实现
type StdLogger struct {
    logger *log.Logger
}

func (l *StdLogger) Info(msg string, fields ...Field) {
    l.logger.Printf("[INFO] %s %s", msg, formatFields(fields))
}

// 使用示例
logger.Info("API Request",
    logger.Field("url", url),
    logger.Field("method", "POST"),
    logger.Field("duration", duration))
```

---

## 八、代码组织最佳实践

### 8.1 单一职责

```go
// ✅ 一个文件一个职责
services/contact/user.go          // 只处理成员相关（400 行）
services/contact/department.go    // 只处理部门相关（400 行）
services/contact/tag.go           // 只处理标签相关（300 行）

// ❌ 避免：一个文件包含所有逻辑
services/contact/contact.go       // 3000+ 行，难以维护
```

### 8.2 合理的文件大小

- 单文件控制在 300-500 行
- 单个方法不超过 50 行
- 复杂逻辑拆分为多个小函数

### 8.3 清晰的命名

```go
// ✅ 服务命名
services/contact/         → ContactService
services/externalcontact/ → ExternalContactService
services/message/         → MessageService

// ✅ 类型命名（带业务前缀）
types/contact/user.go            → contact.User
types/message/text.go            → message.TextMessage
types/externalcontact/customer.go → externalcontact.Customer
```

### 8.4 依赖管理

```
清晰的依赖层次：
wecom.Client
  └─> services/*
        └─> internal/client
              ├─> internal/auth
              ├─> internal/retry
              └─> internal/errors
```

---

## 九、质量保证

### 9.1 代码规范

- 遵循 Go 官方编码规范
- 使用 `golangci-lint` 静态检查
- 代码注释覆盖率 > 80%
- 所有导出函数必须有 GoDoc 注释

### 9.2 测试覆盖

- **单元测试**：覆盖率 > 80%
- **集成测试**：覆盖核心流程
- **压力测试**：验证并发场景
- **Mock 测试**：不依赖真实 API

### 9.3 文档完善

1. **README.md**
   - 快速开始
   - 安装说明
   - 基础示例
   - 配置说明

2. **GoDoc 注释**
   - 所有公开 API 必须有注释
   - 注释包含使用示例
   - 注意事项说明

3. **examples/**
   - 基础使用示例
   - 各业务模块示例
   - 最佳实践示例

4. **最佳实践文档**
   - Token 管理建议
   - 错误处理建议
   - 并发使用建议
   - 性能优化建议

### 9.4 版本管理

- 遵循语义化版本（Semantic Versioning）
- v0.x.x：开发阶段，API 可能变化
- v1.0.0：第一个稳定版本
- CHANGELOG.md 记录变更

---

## 十、后续扩展方向

### 10.1 功能扩展

1. 支持更多企业微信 API 模块（30+）
2. 提供 Webhook 回调处理能力
3. 支持第三方应用开发模式
4. 提供服务商模式支持

### 10.2 工具扩展

1. CLI 工具
   - 快速测试 API
   - 生成示例代码
   - 批量操作工具

2. 代码生成器
   - 根据 OpenAPI 规范生成代码
   - 自动生成类型定义
   - 减少重复劳动

### 10.3 可观测性

1. **Metrics（指标）**
   - Prometheus 集成
   - 请求成功率、延迟统计
   - Token 刷新次数统计

2. **Tracing（追踪）**
   - OpenTelemetry 集成
   - 分布式追踪
   - 请求链路分析

3. **Logging（日志）**
   - 结构化日志
   - 日志聚合（ELK、Loki）
   - 日志采样

### 10.4 高级特性

1. **分布式缓存**
   - Redis 集群支持
   - Token 共享（多实例部署）

2. **熔断降级**
   - 熔断器模式
   - 降级策略
   - 服务保护

3. **插件系统**
   - 中间件支持
   - 自定义拦截器
   - 扩展点机制

---

## 十一、里程碑

| 阶段 | 时间 | 交付成果 | 状态 |
|-----|------|---------|------|
| 阶段一 | Week 1 | 基础框架 | ⏳ 待开始 |
| 阶段二 | Week 1-2 | 认证与重试 | ⏳ 待开始 |
| 阶段三 | Week 2-3 | 通讯录模块 | ⏳ 待开始 |
| 阶段四 | Week 3-6 | 核心业务模块（P0/P1） | ⏳ 待开始 |
| 阶段五 | Week 6-7 | 测试与优化 | ⏳ 待开始 |
| 阶段六 | Week 8+ | 工具与扩展（可选） | ⏳ 待开始 |

---

## 十二、风险与应对

### 12.1 技术风险

**风险**：企业微信 API 变更
- **应对**：
  - 版本化 API 支持
  - 兼容性测试
  - 及时更新文档

**风险**：性能瓶颈
- **应对**：
  - 压力测试
  - 性能监控
  - 连接池优化

### 12.2 开发风险

**风险**：工期延期
- **应对**：
  - 分阶段交付
  - 优先级排序（P0 → P1 → P2）
  - 及时沟通调整

**风险**：测试覆盖不足
- **应对**：
  - TDD 开发模式
  - 持续集成（CI）
  - 代码审查

---

## 十三、总结

本开发计划旨在构建一个：

- ✅ **功能完善**：支持 30+ 个企业微信业务模块
- ✅ **易于使用**：简洁的 API 设计，丰富的示例
- ✅ **高度可靠**：自动重试、Token 管理、错误处理
- ✅ **可扩展性**：清晰的架构，易于添加新模块
- ✅ **可维护性**：代码规范、测试完善、文档齐全
- ✅ **生产级别**：日志监控、性能优化、稳定性保障

通过分阶段实施，先完成核心框架和关键模块，再逐步扩展其他功能，确保项目稳步推进。
